# RocoR's OI Note 第二章 数据结构

本笔记基于AcWing《算法基础课》第2章 数据结构

## 链表

### 模拟单链表

> **模板：**
>
> ```cpp
> int e[N], ne[N]; // 链表元素及下个结点的地址
> int head;       // 头结点地址
> int idx;        // 当前可用位置
> 
> /** 创建含头结点的单链表 */
> void init() {
>     head = 0;
> 
>     // 头结点
>     e[0] = 0;       // 值为链表长度
>     ne[0] = -1;     
> 
> 
>     idx = 1;        // 第1个结点的下标从1开始
> }
> 
> /** 向链表头部插入一个数 */
> void insert_head(int x) {
>     e[idx] = x;
>     ne[idx] = ne[head];
>     ne[head] = idx;
>     idx++;
> 
>     e[0]++;     // 链表长度+1
> }
> 
> /** 删除下标为k后面的数 */
> void rem(int k) {
>     ne[k] = ne[ne[k]];
>     e[0]--;     // 链表长度-1
> }
> 
> /** 在下标为k的位置后插入一个数 */
> void insert(int k, int x) {
>     e[idx] = x;
>     ne[idx] = ne[k];
>     ne[k] = idx;
>     idx++;
> 
>     e[0]++;     // 链表长度+1
> }
> 
> /** 遍历链表 */
> void print() {
>     for (int i = ne[head]; i != -1; i = ne[i]) cout << e[i] << " ";
> }
> ```
>
> **说明：**
>
> * 采用含**头结点**的单链表，头结点存储链表长度
>
> * 元素从下标`1`开始存储

### 模拟双链表

>**模板：**
>
>```cpp
>const int N = 100010;
>int e[N], l[N], r[N], idx;
>
>/** 创建双链表（含头结点和尾结点） */
>void init() {
>    r[0] = 1;       // 头结点
>    l[1] = 0;       // 尾结点
>    idx = 2;
>}
>
>/** 在下标为k的结点右侧插入一个结点 */
>void insert(int k, int x) {
>    e[idx] = x;
>    r[idx] = r[k];
>    l[idx] = k;
>    l[r[k]] = idx;
>    r[k] = idx;
>    idx++;
>}
>
>/** 删除下标为k的结点 */
>void remove(int k) {
>    r[l[k]] = r[k];
>    l[r[k]] = l[k];
>}
>
>/** 输出 */
>void print() {
>    for (int i = r[0]; i != 1; i = r[i]) printf("%d ", e[i]);
>}
>```
>
>**说明：**
>* 实现的双链表含**头结点**和**尾结点**，下标分别为`0`和`1`
>* `insert()`函数可根据参数的选取实现在链表任意位置插入的功能（包括头插和尾插）
>* 遍历时从头结点的下一个位置开始（`r[0]`），直到遍历到尾结点（下标为`0`）

## 模拟栈

> **模板：**
>
> ```cpp
> int stk[N], tt = 0;     // tt表示栈顶
> 
> // 向栈顶插入一个数
> stk[ ++ tt] = x;
> 
> // 从栈顶弹出一个数
> tt -- ;
> 
> // 栈顶的值
> stk[tt];
> 
> // 判断栈是否为空
> if (tt) {...}       // 栈不为空
> ```
>
> **说明：**
>
> * 栈从下标`1`开始存储元素
>
> * 栈顶指针`tt`的值可表示栈的实际长度

## 模拟队列

### 普通队列

> **模板：**
>
> ```cpp
> // hh 表示队头，tt表示队尾
> int q[N], hh = 0, tt = -1;
> 
> // 向队尾插入一个数
> q[ ++ tt] = x;
> 
> // 从队头弹出一个数
> hh ++ ;
> 
> // 队头的值
> q[hh];
> 
> // 判断队列是否为空
> if (hh > tt){...}
> ```
>
> **说明：**
> `tt - hh + 1`可表示队列长度

### 循环队列

> **模板：**
>
> ```cpp
> // hh 表示队头，tt表示队尾的后一个位置
> int q[N], hh = 0, tt = 0;
> 
> // 向队尾插入一个数
> q[tt ++ ] = x;
> if (tt == N) tt = 0;
> 
> // 从队头弹出一个数
> hh ++ ;
> if (hh == N) hh = 0;
> 
> // 队头的值
> q[hh];
> 
> // 判断队列是否为空
> if (hh == tt){...}
> ```
>
> 说明：
>
> * 这种实现方式与普通队列方式有点区别，在这里是先存入，后`++`，故`tt`初值为`0`
>
> * 可以把入队改成`q[tt] = x; tt = (tt + 1) % N;`，出队改成`hh = (hh + 1) % N; x = q[hh];`
>
> * 队满判断可用`(tt + 1) % N == hh`
>
> * 队列长度可用`(tt - hh + N) % N`求出

## 单调栈

> **用途：**
>
> 为数组中每个数找出满足如下条件的数：
>
> * 在它左（右）边
> * 距离最近
> * 比它小（大）
>
> **单调栈维护核心思想：**
> 
> 为了使为每个元素寻找 **“左侧第一个比它小的元素”** 的时间复杂度下降，在序列从左向右遍历时，栈中要呈一个**单调递减（自顶向下）**趋势。这样遍历过程中，对于新元素，只需一直弹出大于等于它的栈顶元素，直到找到一个比它小的元素，这个元素就是左侧第一个比它小的元素。
>
> 为了维护这种单调性，序列中每进入一个新元素，需要**检查栈顶加入这个新元素后是否依然保持单调递减**，若否（即当前栈顶元素大于等于新元素，不满足单调递增），则一直弹出栈顶，直到栈顶小于新元素或者栈空为止。
>
> 此时，如果栈不为空，则**新的栈顶元素即为新元素的“上一个更小元素”**；如果栈为空，则说明新元素的左侧不存在比它小的元素。随后，新元素加入栈顶。
>
> 寻找“上一个更大元素”同理，只需维护一个**单调递增**栈。代码上看，只需把上述说明中栈顶弹出条件改为栈顶小于等于新元素就弹出即可。
>
> **模板：**
>
> ```cpp
> int tt = 0;
> for (int i = 1; i <= n; i ++ )
> {
>     while (tt && check(stk[tt], i)) tt -- ;
>     stk[ ++ tt] = i;
> }
> 
> STL使用例：找当前元素左侧最近且小于当前元素的数
> for(int i = 0; i < n; i++){
> 	cin >> a[i];        
> // 栈非空时，若栈顶元素大于等于当前元素，则不满足从栈顶到栈底的单调递减性，弹出栈顶，循环直到栈顶元素小于当前元素为止
> 	while (!stk.empty() && stk.top() >= a[i]) stk.pop();    
> 	if (stk.empty()) cout << "-1 ";  //不存在这个数
> 	else cout << stk.top() << " ";	 //找到了，输出这个数
> 	stk.push(a[i]);//将当前元素加入栈
>     }
> ```
>
> **说明：**
> 总时间复杂度由$O(n^2)$降为$O(n)$

## 单调队列

>**用途：**
>找出滑动窗口中的最大值（最小值）
>
>**队列维护核心思想：**
>
>为了使查找最小值的时间复杂度降为O(1)，在窗口向后推进时，队列中要呈一个**单调递增**趋势，这样推进过程中队首即使不断因离开窗口而弹出，新的**队首**也**保持为当前窗口最小值**。
>
>为了维护这种单调性，窗口中每进入一个新元素，需要**检查队尾加入这个新元素后是否依然保持单调递增**，若否（即当前队尾元素大于等于新元素，不满足单调递增），则一直弹出队尾，直到队尾小于新元素或者队列空为止，随后，新元素加入队尾。
>
>此时，队首即为当前窗口最小值。
>
>最大值同理，只需维护一个**单调递减**队列。代码上看，只需把最小值代码中队尾弹出条件改为队尾小于等于新元素就弹出即可
>
>```cpp
>int hh = 0, tt = -1;
>for (int i = 0; i < n; i ++ )
>{
>while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
>while (hh <= tt && check(q[tt], i)) tt -- ;
>q[ ++ tt] = i;
>}
>
>STL使用例：输出滑动窗口中最小值
>// n为数组长度，k为窗口长度
>// 维护从队首到队尾的单调递增队列，队首即为当前窗口最小值
>for(int i = 0; i < n; i++){
>	if (!q.empty() && q.front() < i - k + 1) q.pop_front(); //如果队首已经离开窗口，弹出队首
>
>	while (!q.empty() && a[q.back()] >= a[i]) q.pop_back(); //维护单调性
>	q.push_back(i); //加入新元素
>
>	if (i >= k - 1) cout << a[q.front()] << " ";   // 窗口全部进入数组时再开始输出
>}
>```
>
>**说明：**
>总时间复杂度由$O(nk)$降为$O(n+k)$


