# RocoR's OI Note 第二章 数据结构

本笔记基于AcWing《算法基础课》第2章 数据结构

## 链表

### 模拟单链表

> **模板：**
>
> ```cpp
> int e[N], ne[N]; // 链表元素及下个结点的地址
> int head;       // 头结点地址
> int idx;        // 当前可用位置
> 
> /** 创建含头结点的单链表 */
> void init() {
>     head = 0;
> 
>     // 头结点
>     e[0] = 0;       // 值为链表长度
>     ne[0] = -1;     
> 
> 
>     idx = 1;        // 第1个结点的下标从1开始
> }
> 
> /** 向链表头部插入一个数 */
> void insert_head(int x) {
>     e[idx] = x;
>     ne[idx] = ne[head];
>     ne[head] = idx;
>     idx++;
> 
>     e[0]++;     // 链表长度+1
> }
> 
> /** 删除下标为k后面的数 */
> void rem(int k) {
>     ne[k] = ne[ne[k]];
>     e[0]--;     // 链表长度-1
> }
> 
> /** 在下标为k的位置后插入一个数 */
> void insert(int k, int x) {
>     e[idx] = x;
>     ne[idx] = ne[k];
>     ne[k] = idx;
>     idx++;
> 
>     e[0]++;     // 链表长度+1
> }
> 
> /** 遍历链表 */
> void print() {
>     for (int i = ne[head]; i != -1; i = ne[i]) cout << e[i] << " ";
> }
> ```
>
> **说明：**
>
> * 采用含**头结点**的单链表，头结点存储链表长度
>
> * 元素从下标`1`开始存储

### 模拟双链表

>**模板：**
>
>```cpp
>const int N = 100010;
>int e[N], l[N], r[N], idx;
>
>/** 创建双链表（含头结点和尾结点） */
>void init() {
>r[0] = 1;       // 头结点
>l[1] = 0;       // 尾结点
>idx = 2;
>}
>
>/** 在下标为k的结点右侧插入一个结点 */
>void insert(int k, int x) {
>e[idx] = x;
>r[idx] = r[k];
>l[idx] = k;
>l[r[k]] = idx;
>r[k] = idx;
>idx++;
>}
>
>/** 删除下标为k的结点 */
>void remove(int k) {
>r[l[k]] = r[k];
>l[r[k]] = l[k];
>}
>
>/** 输出 */
>void print() {
>for (int i = r[0]; i != 1; i = r[i]) printf("%d ", e[i]);
>}
>```
>
>**说明：**
>
>* 实现的双链表含**头结点**和**尾结点**，下标分别为`0`和`1`
>
>* `insert()`函数可根据参数的选取实现在链表任意位置插入的功能（包括头插和尾插）
>
>* 遍历时从头结点的下一个位置开始（`r[0]`），直到遍历到尾结点（下标为`0`）

## 模拟栈

> **模板：**
>
> ```cpp
> int stk[N], tt = 0;     // tt表示栈顶
> 
> // 向栈顶插入一个数
> stk[ ++ tt] = x;
> 
> // 从栈顶弹出一个数
> tt -- ;
> 
> // 栈顶的值
> stk[tt];
> 
> // 判断栈是否为空
> if (tt) {...}       // 栈不为空
> ```
>
> **说明：**
>
> * 栈从下标`1`开始存储元素
>
> * 栈顶指针`tt`的值可表示栈的实际长度

## 模拟队列

### 普通队列

> **模板：**
>
> ```cpp
> // hh 表示队头，tt表示队尾
> int q[N], hh = 0, tt = -1;
> 
> // 向队尾插入一个数
> q[ ++ tt] = x;
> 
> // 从队头弹出一个数
> hh ++ ;
> 
> // 队头的值
> q[hh];
> 
> // 判断队列是否为空
> if (hh > tt){...}
> ```
>
> **说明：**
> `tt - hh + 1`可表示队列长度

### 循环队列

> **模板：**
>
> ```cpp
> // hh 表示队头，tt表示队尾的后一个位置
> int q[N], hh = 0, tt = 0;
> 
> // 向队尾插入一个数
> q[tt ++ ] = x;
> if (tt == N) tt = 0;
> 
> // 从队头弹出一个数
> hh ++ ;
> if (hh == N) hh = 0;
> 
> // 队头的值
> q[hh];
> 
> // 判断队列是否为空
> if (hh == tt){...}
> ```
>
> 说明：
>
> * 这种实现方式与普通队列方式有点区别，在这里是先存入，后`++`，故`tt`初值为`0`
>
> * 可以把入队改成`q[tt] = x; tt = (tt + 1) % N;`，出队改成`hh = (hh + 1) % N; x = q[hh];`
>
> * 队满判断可用`(tt + 1) % N == hh`
>
> * 队列长度可用`(tt - hh + N) % N`求出

## 单调栈

> **用途：**
>
> 为数组中每个数找出满足如下条件的数：
>
> * 在它左（右）边
> * 距离最近
> * 比它小（大）
>
> **单调栈维护核心思想：**
> 为了使为每个元素寻找 **“左侧第一个比它小的元素”** 的时间复杂度下降，在序列从左向右遍历时，栈中要呈一个**单调递减（自顶向下）**趋势。这样遍历过程中，对于新元素，只需一直弹出大于等于它的栈顶元素，直到找到一个比它小的元素，这个元素就是左侧第一个比它小的元素。
>
> 为了维护这种单调性，序列中每进入一个新元素，需要**检查栈顶加入这个新元素后是否依然保持单调递减**，若否（即当前栈顶元素大于等于新元素，不满足单调递增），则一直弹出栈顶，直到栈顶小于新元素或者栈空为止。
>
> 此时，如果栈不为空，则**新的栈顶元素即为新元素的“上一个更小元素”**；如果栈为空，则说明新元素的左侧不存在比它小的元素。随后，新元素加入栈顶。
>
> 寻找“上一个更大元素”同理，只需维护一个**单调递增**栈。代码上看，只需把上述说明中栈顶弹出条件改为栈顶小于等于新元素就弹出即可。
>
> **模板：**
>
> ```cpp
> int tt = 0;
> for (int i = 1; i <= n; i ++ )
> {
>     while (tt && check(stk[tt], i)) tt -- ;
>     stk[ ++ tt] = i;
> }
> 
> STL使用例：找当前元素左侧最近且小于当前元素的数
> for(int i = 0; i < n; i++){
> 	cin >> a[i];        
> // 栈非空时，若栈顶元素大于等于当前元素，则不满足从栈顶到栈底的单调递减性，弹出栈顶，循环直到栈顶元素小于当前元素为止
> 	while (!stk.empty() && stk.top() >= a[i]) stk.pop();    
> 	if (stk.empty()) cout << "-1 ";  //不存在这个数
> 	else cout << stk.top() << " ";	 //找到了，输出这个数
> 	stk.push(a[i]);//将当前元素加入栈
>     }
> ```
>
> **说明：**
> 总时间复杂度由$O(n^2)$降为$O(n)$

## 单调队列

>**用途：**
>找出滑动窗口中的最大值（最小值）
>
>**队列维护核心思想：**
>为了使查找最小值的时间复杂度降为O(1)，在窗口向后推进时，队列中要呈一个**单调递增**趋势，这样推进过程中队首即使不断因离开窗口而弹出，新的**队首**也**保持为当前窗口最小值**。
>
>为了维护这种单调性，窗口中每进入一个新元素，需要**检查队尾加入这个新元素后是否依然保持单调递增**，若否（即当前队尾元素大于等于新元素，不满足单调递增），则一直弹出队尾，直到队尾小于新元素或者队列空为止，随后，新元素加入队尾。
>
>此时，队首即为当前窗口最小值。
>
>最大值同理，只需维护一个**单调递减**队列。代码上看，只需把最小值代码中队尾弹出条件改为队尾小于等于新元素就弹出即可
>
>```cpp
>int hh = 0, tt = -1;
>for (int i = 0; i < n; i ++ )
>{
>while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
>while (hh <= tt && check(q[tt], i)) tt -- ;
>q[ ++ tt] = i;
>}
>
>STL使用例：输出滑动窗口中最小值
>// n为数组长度，k为窗口长度
>// 维护从队首到队尾的单调递增队列，队首即为当前窗口最小值
>for(int i = 0; i < n; i++){
>	if (!q.empty() && q.front() < i - k + 1) q.pop_front(); //如果队首已经离开窗口，弹出队首
>
>	while (!q.empty() && a[q.back()] >= a[i]) q.pop_back(); //维护单调性
>	q.push_back(i); //加入新元素
>
>	if (i >= k - 1) cout << a[q.front()] << " ";   // 窗口全部进入数组时再开始输出
>}
>```
>
>**说明：**
>总时间复杂度由$O(nk)$降为$O(n+k)$

## KMP

### 朴素模式匹配算法(BF算法)

> ```cpp
> //S为主串，T为模式串
> //读入时从下标1开始，如：cin >> S + 1
> int Index(char* S[], char* T[]){
>     int i = 1, j = 1;
>     while (i <= strlen(S + 1) && j <= strlen(T + 1)){
>         if (S[i] == T[j]){
>             i++;j++;	//当前字符匹配，则继续比较后续字符
>         }
>         else{
>             i = i - j + 2;
>             j = 1;		//匹配失败，i指针回溯到主串的下一个位置，j指针回溯到1
>         }
>     }
>     if (j > strlen(T + 1))
>         return i - strlen(T + 1);		//匹配成功，返回子串位置
>     else
>         return 0;
> }
> 
> //另一种写法,下标从0开始
> /*
>  * s：待匹配的主串
>  * t：模式串
>  * n：主串的长度
>  * m：模式串的长度
>  */
> std::vector<int> match(char *s, char *t, int n, int m) {
>   std::vector<int> ans;
>   int i, j;
>   for (i = 0; i < n - m + 1; i++) {
>     for (j = 0; j < m; j++) {
>       if (s[i + j] != t[j]) break;
>     }
>     if (j == m) ans.push_back(i);
>   }
>   return ans;
> }
> ```
>
> **时间复杂度：**$O(nm)$（主串长度为n，模式串长度为m）

### KMP

>KMP算法是一种字符串匹配算法，它的核心在于利用已经部分匹配的信息，通过一个next数组（也称为前缀函数）来避免从头重新匹配。
>
>**模板：**
>
>```cpp
>// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度
>
>// 求模式串的Next数组（实质是模式串的自我匹配）：
>for (int i = 2, j = 0; i <= m; i ++ )
>{
>while (j && p[i] != p[j + 1]) j = ne[j];
>if (p[i] == p[j + 1]) j ++ ;
>ne[i] = j;
>}
>
>// 匹配
>// i为主指针，遍历文本串或模式串的当前位置；j为匹配长度指针，记录当前**已匹配成功**的字符个数，所以s[i]与p[j + 1]比较
>for (int i = 1, j = 0; i <= n; i ++ )
>{
>while (j && s[i] != p[j + 1]) j = ne[j];
>if (s[i] == p[j + 1]) j ++ ;
>if (j == m)
>{
>   j = ne[j];
>   // 匹配成功后的逻辑，如：输出匹配子串位置i - m + 1，记录匹配次数count++
>}
>}
>
>```
>
>**时间复杂度：**$O(n+m)$
>
>**说明：**
>
>* 使用KMP算法时，起始下标为`1`
>* 字符串可用`char`数组保存，读入时用`cin >> p + 1`读取，表示从下标`1`开始写入字符串，获取长度用`strlen(p + 1)`
>* `ne` 数组是KMP算法的核心，通常被称为 **Next数组** 或 **前缀函数**。`ne[i]` 的含义是：在模式串 `p` 中，对于子串 `p[1...i]`，其 **最长的、相等的、真前缀和真后缀** 的长度
>* 用 `O(m)` 的额外空间（Next数组）换取 `O(n+m)` 的时间复杂度，远优于暴力匹配的 `O(n×m)`

## Trie树

> **定义：**
> 一种能够快速插入和查找字符串集合的多叉树结构，又称**字典树**
> 节点的编号各不相同，根节点编号为0，其他节点用于标识路径，还可以标记单词插入次数。树的边表示字符。
>
> **模板：**
>
> ```cpp
> int son[N][26], cnt[N], idx = 1;
> // 0号点既是根节点，又是空节点
> // son[p][j]存储从节点p沿着j这条边走到的子节点,son[父亲的地址][儿子的代号]=儿子的地址
> // cnt[p]存储以节点p结尾的单词数量
> // idx为当前可用位置,用来给节点编号
> 
> // 插入一个字符串
> void insert(char *str[])
> {
> int p = 0;
> for (int i = 0; str[i]; i ++ )	  //以str[i]作为循环条件，意为str有效数据遍历完后，下一个位置是0，退出
> {
>   int u = str[i] - 'a';           //将字母按a-z对应0-25转为数字代号
>   if (!son[p][u]) son[p][u] = idx ++;     // 不存在结点则创建结点
>   p = son[p][u];                        // 指针p指向新结点
> }
> cnt[p] ++ ;		// 字符串插入完成后，结尾处添加结束标记
> }
> 
> // 查询字符串出现的次数
> int query(char *str[])
> {
> int p = 0;
> for (int i = 0; str[i]; i ++ )
> {
>   int u = str[i] - 'a';
>   if (!son[p][u]) return 0;
>   p = son[p][u];
> }
> return cnt[p];
> }
> ```
>
> **说明：**
>
> * Trie树共享前缀，结点存在不代表根到该结点的字符串存在，需要看标记数组`cnt`
>
> * Trie树是**多重集合**
>
> * `son`数组的第`1`维表示结点地址，容量要大于所有存储的字符串长度的和（不是字符串长度的最大值）；第`2`维表示每个结点的孩子的代号，容量为最大分支数，一般取字符种类数（如小写字母有26个）
>
> * `cnt[i]`表示以`son[i]`结点为末尾的字符串的个数

## 并查集

**用途：**

1. 将两个集合合并
2. 询问两个元素是否在同一个集合当中

**基本原理：**

每个集合用一棵树来表示。树根的编号就是整个集合的编号。用p[x]存储编号为x的元素的父节点编号

### 朴素并查集

> **模板：**
>
> ```cpp
> int p[N]; //存储每个点的祖先节点
> 
> // 返回x的祖先节点
> int find(int x)
> {
>     if (p[x] != x) p[x] = find(p[x]);       // 路径压缩
>     return p[x];
> }
> 
> // 初始化，假定节点编号是1~n
> for (int i = 1; i <= n; i ++ ) p[i] = i;
> 
> // 合并a和b所在的两个集合：
> p[find(a)] = find(b);
> 
> // 判断两个结点是否属于同一集合
> if (find(a) == find(b)) {...}
> ```
>
> **说明：**
>
> * 此模板中规定：若p[x] = x，即一个数的祖先是自己，那么这个结点是根
>
> * 查找函数中使用了**路径压缩**优化并查集结构，通过**递归**使得路径上每个非根结点直接连到根节点上，每棵树的深度不超过`2`
>
> * 判断两个数是否属于同一个集合等价于判断两个数的祖先结点是否相同，即`find(a) == find(b)`
>
> * 合并操作本质是把其中一个数的祖宗结点连接到另一个数的祖宗结点上

### 维护size的并查集

> **模板：**
>
> ```cpp
> int p[N], size[N];                  // 变动部分
> //p[]存储每个点的祖先节点
> //只有根节点的size[]有意义，表示其所在集合中的元素的数量，故使用size时必须与find函数共同使用：size[find(x)]
> 
> // 返回x的祖先节点
> int find(int x)
> {
>     if (p[x] != x) p[x] = find(p[x]);
>     return p[x];
> }
> 
> // 初始化，假定节点编号是1~n
> for (int i = 1; i <= n; i ++ )
> {
>     p[i] = i;
>     size[i] = 1;                    // 变动部分，初始化size数组
> }
> 
> // 合并a和b所在的两个集合：
> int x = find(a), y = find(b);
> if (x != y) {		//a、b若已连通，则无需再次连接，否则集合size大小会翻倍
>     p[x] = y;
>     size[y] += size[x];
> }
> 
> // 判断两个结点是否属于同一集合
> if (find(a) == find(b)) {...}
> ```
>
> **说明：**
>
> * `size[x]`存储的是以该结点为根的树的结点个数
>
> * 在合并操作中，可以不必把`find(a)`和`find(b)`存入两个变量。因为第一次调用`find()`时会进行**路径压缩**，下一次调用就是`O(1)`复杂度了。但要注意先修改size再合并结点，二者顺序不可颠倒，因为结点含义会改变
>
> * 改变`size`时，要先判断两个集合是否为同一个
>
> * 在两个彼此不连通的连通图加上一条边连通二者，等价于把两个集合合并
>
> * 为了避免合并步骤中出现顺序问题，可以用两个变量表示，同时也减少了代码量

### 维护到根节点距离的并查集

> **模板：**
>
> ```cpp
> int p[N], d[N];
> //p[]存储每个点的祖先节点, d[x]存储x到p[x]的距离
> 
> // 返回x的祖先节点
> int find(int x)
> {
>     if (p[x] != x)
>     {
>         int u = find(p[x]);         // 先更新d[p[x]]
>         d[x] += d[p[x]];            // 再更新d[x]
>         p[x] = u;                   // 最后更新p[x]
>     }
>     return p[x];
> }
> 
> // 初始化，假定节点编号是1~n
> for (int i = 1; i <= n; i ++ )
> {
>     p[i] = i;
>     d[i] = 0;                       // 自身到自身的距离是0
> }
> 
> // 合并a和b所在的两个集合：
> p[find(a)] = find(b);
> d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量
> ```
>
> **说明：**
>
> * 注意`find`函数语句的先后次序，次序不对可能会导致含义错误

## 堆

### 一般的堆

> **模板：**
>
> ```cpp
> // 以最小堆为例
> // h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1
> int h[N], hsize;
> 
> // 下调操作
> void down(int u)
> {
>        int t = u;
>     	if (u * 2 <= hsize && h[u * 2] < h[t]) t = u * 2;
>     	if (u * 2 + 1 <= hsize && h[u * 2 + 1] < h[t]) t = u * 2 + 1;
>     	if (u != t)
>     {
>         swap(h[u], h[t]);
>         down(t);
>     }
> }
> 
> // 上调操作
> void up(int u)
> {
>     	while (u / 2 && h[u] < h[u / 2])
>     	{
>            swap(h[u], h[u / 2]);
>         	u /= 2;
>     	}
> }
> 
> // --------------------------------基本操作--------------------------------
> // 0. 快速建堆
> void initHeap(){
>     	for (int i = hsize / 2; i; i -- ) down(i);
> }
> 
> // 1. 插入一个数（可用于朴素建堆）
> void insert(int x){
>     	hsize++;
>     	h[hsize] = x;
>     	up(hsize);  
> }
> 
> // 2. 求最小值
> int top() {
>     	return h[1];
> }
> 
> // 3. 删除最小值
> void removeMin(){
>     	h[1] = h[size];
>     	size--;
>     	down(1);
> }
> 
> // 4. 删除任意位置的元素（STL没有）
> void removek(int k){
>     	h[k] = h[size];
>     	size--;
>     	down(k), up(k);
> }
> 
> // 5. 修改任意位置的元素（STL没有）
> void updatek(int k, int x){
>     	h[k] = x;
>     	down(k);
>     	up(k);
> }
> ```
>
> **说明：**
>
> * 所有基本操作都可由`up()`和`down()`组合而成
>
> * 建堆的时间可以看做是`O(n)`，由错位相减法可知调整次数<n
>
> * 实现`down()`时，注意`t`的含义是当前值最小结点的下标，是变化的，而`u`是不变的，不要与`u`的含义弄混
>
> * STL没有**基本操作4**和**基本操作5**，尽管它们实现时同时调用了`down()`和`up()`，但实际上只会执行其中一个
>
> * 快速建堆是从`n/2`逆着遍历到`1`

### 可索引堆

> 又称**维护插入顺序的堆**/**带映射的堆**/**支持任意删除的堆**
>
> 在**Dijkstra算法**中会用到
>
> **模板：**
>
> ```cpp
> // h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1
> // ph[k]存储第k个插入的点在堆中的下标，position to heap index
> // hp[k]存储堆中下标是k的点是第几个插入的，heap index to position
> // 即：ph[]用于已知次序找下标；hp[]用于已知下标找次序
> // idx用于在插入时写入次序
> int h[N], hsize, ph[N], hp[N], idx;
> 
> // 为了实现对第k个插入数的操作，需要加强swap函数，注意此函数传入参数为结点下标
> // 必须时刻保持ph[k] = i,hp[i] = k这样的双向映射关系
> void heapSwap(int a, int b){
>  	swap(ph[hp[a]], ph[hp[b]]);
>  	swap(hp[a], hp[b]);
>  	swap(h[a], h[b]);
> }
> 
> void down(int u){
>      int t = u;
>  	if (u * 2 <= hsize && h[u * 2] < h[t]) t = u * 2;
>  	if (u * 2 + 1 <= hsize && h[u * 2 + 1] < h[t]) t = u * 2 + 1;
>  	if (u != t){
>      		heapSwap(u, t);
>      		down(t);
>  	}
> }
> 
> void up(int u){
>  	while (u / 2 && h[u] < h[u / 2]){
>      		heapSwap(u, u / 2);
>      		u /= 2;
>  	}
> }
> 
> // --------------------------------基本操作--------------------------------
> // 0. 建堆
> // 由于需要记录插入顺序，这种堆不能使用快速建堆法，只能依次插入（朴素建堆）
> 
> // 1. 插入一个数
> void insert(int x){
>  	hsize++;
>  	idx++;
>  	h[hsize] = x;
>  	ph[idx] = hsize;
>  	hp[hsize] = idx;
>  	up(hsize);
> }
> 
> // 2. 求最小值
> int top() {
>  	return h[1];
> }
> 
> // 3. 删除最小值
> void removeTop(){
>  	heapSwap(1, hsize);
>  	hsize--;
>  	down(1);
> }
> 
> // 4. 删除第k次插入的元素（STL没有）
> void removek(int k){
>  	int pos = ph[k];    // ph[k]会在hsize--后失效，需要提前用一个变量存储
>  	heapSwap(ph[k], hsize);
>  	hsize--;
>  	down(pos), up(pos);
> }
> 
> // 5. 修改第k次插入的元素（STL没有）
> void updatek(int k, int x){
>  	h[ph[k]] = x;
>  	down(ph[k]), up(ph[k]);
> }
> ```
>
> **说明：**
>
> * 可索引堆额外存储了插入记录`ph`，**映射**插入次序和元素在堆中的位置，同时构建了`ph`的**逆映射**`hp`，可根据堆中的下标反推插入次序
>
> * 基本操作中所有`swap()`改成加强版的`heapSwap()`，因为要维护`ph`和`hp`
>
> * 在`heapSwap`中，由于参数是下标，但`ph`数组需要提供插入序号`k`，因此可用数组`hp`的值来作为`ph`的参数

## 哈希表

> **模板：**
>
> ```cpp
> // (1) 拉链法
> int h[N],  // Head array：哈希表的头节点数组，存储每个槽位对应链表的第一个元素的索引
> e[N],  // Element array：存储每个节点的实际数据值
> ne[N], // Next array：存储每个节点的下一个节点的索引（模拟链表指针）
> idx;   // Index：当前可用的新节点位置（相当于内存分配指针）
> 
> memset(h, -1, sizeof(h));   // 所有桶初始为空(-1)
> 
> // 向哈希表中插入一个数
> void insert(int x){
> 	int k = (x % N + N) % N;    //计算哈希值，且确保结果非负，确定x应该放在哪个桶中
> 	e[idx] = x;                 //在新节点存储数据
> 	ne[idx] = h[k];             //新节点的next指向原链表头（头插法）
> 	h[k] = idx;                 //桶的头指针指向新节点
> 	idx++;                      //idx移动到下一个空位
> }
> 
> // 在哈希表中查询某个数是否存在
> bool find(int x){
> 	int k = (x % N + N) % N;
> 	for(int i = h[k]; i != -1; i = ne[i])   //遍历该桶对应的链表
> 		if (e[i] == x)                      //比较每个节点的值
> 			return true;
> 
> 	return false;                           //链表遍历完未找到
> }
> 
> // --------------------------------------------------------------------
> // (2) 开放寻址法
> const int null = 0x3f3f3f3f;	// 定义一个值域外的数，用于表示空位
> int h[N];						// 一维数组直接存储所有元素，既是哈希桶也是数据存储区
> 
> memset(h, 0x3f, sizeof(h));      // 给h的每个字节初始化成0x3f，使得每个元素的值都是null
> 
> // 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置
> int find(int x){
> 	int k = (x % N + N) % N;                //计算初始哈希位置
> 	while (h[k] != null && h[k] != x){      //被占用且不是x，就继续找
> 		k++;                                //线性探测：逐个往后找
> 		if (k == N) k = 0;                  //环形处理：到末尾回到开头
> }
> 
> 	return k;           	//返回位置：要么找到x，要么找到可插入的空位
> }
> ```
>
> **说明：**
>
> * `(x % N + N) % N`首先把`x`缩放到满足`abs(x) < N`，由于第一次取模的结果可能是负数，因此还要加N后再进行一次取模
> * **拉链法**和**开放寻址法**都旨在解决**哈希碰撞**问题
> * 用**单链表**实现拉链法
> * 用**质数**作为哈希表长度`N`可以使得**哈希碰撞最少**（数学上能证明）
> * 可以事先实现一个求质数的函数，算出比`N`大的最小质数，作为`N`的值
> * 离散化是哈希的特例，因为离散化要求相对顺序不变（保序），而哈希没有要求（无序）
> * 哈希表的**删除**是通过添加标记实现的，直接删除会引发问题（开放寻址法）
> * 开放寻址法手动设定`null`的值，其值需要在题目数据值域外。例如元素值的绝对值≤1e9，又知`0x3FFFFFFF`>1e9，但`memset()`只能按字节赋值（且int类型为4字节），故可考虑`0x3F3F3F3F`，经检验它>1e9，故可使用`memset(h, 0x3f, sizeof(h));`为哈希表“赋”初值`null`
>
> **注:**
>
> 实际上，上述模板是哈希表的一种**简化形式**，严格来说它实现的是**哈希集合（Hash Set）**。
>
> ### 键与值的分析
>
> **在这段代码中：**
>
> - **键（Key）** = `x`（要插入或查找的数字本身）
> - **值（Value）** = **隐式的存在性**（`true` 或 `false`）
>
> 它只关心"某个数是否存在"，而不需要额外的数据。功能等价于 C++ 的 `unordered_set<int>`。
>
> ------
>
> ### 为什么这样设计？
>
> 这种 **"键即值"** 的设计在竞赛中非常常见，因为：
>
> 1. **场景简化**：很多问题只需要判断"出现过吗"，不需要额外数据
> 2. **节省空间**：少一个值数组 `val[]`
> 3. **速度更快**：减少一次内存访问
>
> ------
>
> ### 对比标准键值对哈希表
>
> 如果实现**完整的键值对**（如 `unordered_map<int, int>`），代码会是：
>
> ```cpp
> // 以拉链法为例
> int h[N], key[N], val[N], ne[N], idx;
> 
> memset(h, -1, sizeof(h));   // 所有桶初始为空(-1)
> 
> // 插入键值对
> void insert(int k, int v) {
>     int bucket = (k % N + N) % N;
>     key[idx] = k;
>     val[idx] = v;      // 额外存储值
>     ne[idx] = h[bucket];
>     h[bucket] = idx++;
> }
> 
> // 按键查找返回值
> int find(int k) {
>     int bucket = (k % N + N) % N;
>     for (int i = h[bucket]; i != -1; i = ne[i])
>         if (key[i] == k)
>             return val[i];  // 返回值而非bool
>     return NOT_FOUND;     // 需自定义哨兵值
> }
> ```

## 字符串哈希

> **用途：**
> `O(1)`代价计算子串的哈希值，快速判断两个子串是否相同
>
> **原理：**
>
> **字符串哈希**把不同的字符串映射成不同的整数。
>
> 1. 把字符串映射成一个**p进制数字**。
>    对于一个长度为`n`的字符串` s`，
>    这样定义 Hash 函数：$ h(s) = \sum_{i=1}^{n} s[i] \times p^{n-i} \pmod{M} $
>    例如，字符串`abc`，长度`n`为3，其哈希函数值为$ap^2 + bp^1 + c$
>    即$97 \times 131^2 + 98 \times 131^1 + 99$（字符以ASCII码参与运算）
> 2. 如果两字符串不一样，Hash 函数值却一样，这样的现象称为**哈希碰撞**。
> 3. 解决哈希碰撞的方法：
>    巧妙设置`p`和`M`的值，保证`p`与`M`互质。
>    - p通常取质数 `131` 或 `13331`，
>    - M通常取大整数$2^{64}$，把哈希函数值数组`h[]`定义为 ULL，超过则自动溢出，等价于对`M`取模。
>
> **实现：**
>
> 1. 求一个字符串的哈希值相当于**求前缀和**，
>
>    求一个字符串的子串的哈希值相当于**求区间和**。
>
> 2. **前缀和**  $ h[i] = h[i-1] \times p + s[i] $，$ h[0] = 0 $（注意与常规前缀和不同，此处要乘上p）
>
> | 字符串 | 哈希值计算                                                   |
> | ------ | ------------------------------------------------------------ |
> | A      | $ A $，$ h[1] \equiv 65 $                                |
> | AB     | $ A \times p^1 + B $，$ h[2] = h[1] \times p + 66 $      |
> | ABC    | $ A \times p^2 + B \times p^1 + C $，$ h[3] = h[2] \times p + 67 $ |
> | ABCD   | $ A \times p^3 + B \times p^2 + C \times p^1 + D $         |
> | ABCDE  | $ A \times p^4 + B \times p^3 + C \times p^2 + D \times p^1 + E $ |
>
> 3. **区间和**  $$ h[l,r] = h[r] - h[l-1] \times p^{r-l+1} $$
>
>    例如，$$ DE = ABCDE - ABC \times p^2 = D \times p^1 + E $$
>
>    即：$$ h[4,5] = h[5] - h[3] \times p^2 $$
>
> 4. 计算前缀和，时间复杂度：$$ O(n) $$
>
>    查询区间和，时间复杂度：$$ O(1) $$
>
> **模板：**
>
> ```cpp
> typedef unsigned long long ULL;
> ULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64
> const int P = 131;          // 或13331
> 
> // 预处理哈希函数前缀和h[] ，同时对P^k打表存入p[]，便于计算区间和
> p[0] = 1， h[0] = 0;
> for (int i = 1; i <= n; i ++ )		// n为主串长度
> {
>     h[i] = h[i - 1] * P + str[i];
>     p[i] = p[i - 1] * P;
> }
> 
> // 计算子串 str[l ~ r] 的哈希值
> ULL get(int l, int r)
> {
>     return h[r] - h[l - 1] * p[r - l + 1];
> }
> 
> // 给定两个区间，判断两子串是否相同
> bool judge(int l1, int r1, int l2, int r2)
> {
>     return get(l1, r1) == get(l2, r2);
> }
> ```
>
