# RocoR's OI Note 第三章 搜索与图论

本笔记基于AcWing《算法基础课》第3章 搜索与图论

## 邻接表

> **用途：**
> 存储稀疏图/树
>
> **模板：**
>
> ```cpp
> //（1）链式前向星
> 
> //邻接表存图：adj[u]指向一个链表的第一个结点，链表中存储从结点u出发的所有有向边(u -> v)中的v
> int adj[N];	
> int e[N], ne[N], idx = 1;	//链表的实现（见第二章模拟单链表）
> 
> // 初始化邻接表，所有结点指向-1，代表空
> memset(adj, -1, sizeof adj);
> 
> // --------------------------------基本操作--------------------------------
> 
> // 向图中添加一条边 a -> b，链表头插法
> void add(int a, int b){
>     e[idx] = b;
>     ne[idx] = adj[a];
>     adj[a] = idx++;
> }
> 
> // 枚举结点 t 的所有邻接点（从 t 能走到的所有结点）
> for (int i = adj[t]; i != -1; i = ne[i]){
>     //......
> }
> 
> 
> //（2）STL vector邻接表
> 
> // 邻接表存图：adj[u]对应一个数组，其中存储从结点u出发的所有有向边(u -> v)中的v
> vector<vector<int>> adj(N);
> 
> // --------------------------------基本操作--------------------------------
> 
> // 向有向图中添加一条边 a -> b
> void add(int a, int b){
>     adj[a].push_back(b);
> }
> 
> // 枚举结点 t 的所有邻接点（从 t 能走到的所有结点）
> for (auto neighbor : adj[t]){
>     //......
> }
> ```



## 深度优先搜索DFS

>  DFS 有一个**通用的逻辑结构**。可以把所有 DFS 代码看作由以下 **4 个部分** 组成的：
>
> 1. **截止条件 (Base Case)**：什么时候停下来？（比如：走到终点了、越界了、或者数字填满了）。
> 2. **当前层逻辑 (Process)**：到了这个节点，我要做什么？（比如：标记我已经来过这里，或者把当前数字加入答案）。
> 3. **下探 (Recursion)**：根据当前状态，尝试所有可能的下一步。
> 4. **回溯 (Backtracking - \*可选\*)**：从深层回来后，要不要恢复现场？
>
> **思路伪代码：**
>
> ```cpp
> void dfs(当前状态参数) {
>     // 1. 截止条件（递归出口）
>     if (到达终点 || 状态不合法) {
>         更新答案;
>         return;
>     }
> 
>     // 2. 遍历所有可能的“下一步”
>     for (每一个可能的选择 in current_options) {
>         
>         // --- 做出选择 ---
>         标记当前选择 (visited[next] = true);
>         记录路径 (path.push(next));
> 
>         // 3. 下探（进入下一层递归）
>         dfs(下个状态参数);
> 
>         // 4. 回溯（恢复现场 - 非常关键！）
>         // 只有在需要“多种组合”或“多次使用同一资源”时才需要这一步
>         撤销标记 (visited[next] = false);
>         撤销路径 (path.pop());
>         // --- 撤销选择 ---
>     }
> }
> ```
>
> 



## 宽度优先搜索BFS

> **模板：**
>
> ```cpp
> // 以最短路问题为例
> // 1. 定义队列 + 距离/访问数组
> queue<int> q;	// 队列，用于存放待扩展的结点（BFS 的核心数据结构）
> vector<int> dist(N, -1);// -1 表示该结点没访问过
> 
> // 2. 初始化起点距离，起点入队
> dist[start] = 0;
> q.push(start);
> 
> // 3. BFS 主循环
> while (!q.empty()) {
>     auto t = q.front();
>     q.pop();
> 
>     // 4. 枚举 t 能走到的所有下一步 next
>     for (所有 next from t) {
>         if (next 合法 && dist[next] == -1) {
>             dist[next] = dist[t] + 1;
>             q.push(next);
>         }
>     }
> }
> 
> // dist[target] 就是答案（如果target不可达，返回-1）
> 
> ```
>
> 

## 拓扑排序（Kahn算法）

> ```cpp
> int q[N], hh = 0, tt = -1;		// q: 模拟队列，存储入度为0的节点
> int d[N];						// d: 存储每个节点的入度 (in-degree)
> 
> // 邻接表存储图：adj[x] 包含所有从 x 出发能到达的节点
> vector<vector<int>> adj(N);
> 
> // 拓扑排序核心函数
> bool topSort(){
>     // 1. 初始化：遍历所有节点（注意题目通常是1到n），将初始入度为0的点入队
>     for (int i = 1; i <= n; i++)
>         if (d[i] == 0)
>             q[++tt] = i; // 入队操作：队尾指针后移并存入值
> 
>     // 2. BFS 循环处理
>     while (hh <= tt){
>         // 出队操作：取出队头元素，队头指针后移
>         int t = q[hh++];
> 
>         // 遍历当前节点 t 的所有邻居 u (即存在边 t -> u)
>         for (auto neighbor : adj[t]){
>             int u = neighbor;
> 
>             // 核心逻辑：既然 t 已经处理完（被删去），u 的入度减 1
>             d[u]--;
> 
>             // 如果 u 的入度变为 0，说明 u 的所有前置条件都满足了，可以入队
>             if (d[u] == 0) q[++tt] = u;
>         }
>     }
> 
>     // 3. 判断结果
>     // 队列中存储了所有进入拓扑序列的点。
>     // 如果入队的点总数等于 n ，说明成功排好序。
>     // 如果小于 n，说明图中存在环，导致环上的点入度永远无法减为 0，也就无法入队。
>     return tt == n - 1;
> }
> ```
>
> **说明：**
>
> * **有向无环图**又称拓扑图
>
> * 有向无环图一定至少存在一个**入度**为0的点（反证法 + 抽屉原理证明）
>
> * 当循环结束后，若队列的长度为`n`，则拓扑排序存在
>
> * 在添加边时，可以顺便统计入度
>
> * 此处使用模拟队列，“弹出”队头时只是指针后移，并未删除元素，这样便于输出排序结果
>
> * 时间复杂度是$O(n+m)$

## Dijkstra

### 朴素Dijkstra算法

> 使用邻接矩阵存储边，适合稠密图
>
> **模板：**
>
> ```cpp
> int g[N][N];  // 邻接矩阵存储每条边
> int dist[N];  // 存储1号点到每个点的最短距离
> bool st[N];   // 存储每个点的最短路是否已经确定
> 
> // 求1号点到n号点的最短路，如果不存在则返回-1
> int dijkstra()
> {
>  memset(dist, 0x3f, sizeof dist);        // 0x3f3f3f3f作为距离的“最大值”
>  dist[1] = 0;                            // 自己到自己的距离为0
> 
>  for (int i = 0; i < n - 1; i ++ )       // 执行n-1次（自己到自己的距离已经确定）
>  {
>      // 在还未确定最短路的点中，寻找距离最小的点
>      int t = -1;
>      for (int j = 1; j <= n; j ++ )
>          if (!st[j] && (t == -1 || dist[t] > dist[j]))
>              t = j;
> 
>      // 用t更新其他点的距离
>      for (int j = 1; j <= n; j ++ )
>          dist[j] = min(dist[j], dist[t] + g[t][j]);
> 
>      st[t] = true;
>  }
> 
>  if (dist[n] == 0x3f3f3f3f) return -1;       // 不可达
>  return dist[n];
> }
> ```
>

> 
